# ES6

## ECMAScript、JavaScript、NodeJs，它们的区别是什么？

ECMAScript：简称ES，是一个语言标准（循环、判断、变量、数组等数据类型）

JavaScript：运行在浏览器端的语言，该语言使用ES标准。 ES + web api = JavaScript

NodeJs：运行在服务器端的语言，该语言使用ES标准。 ES + node api = JavaScript

## ECMAScript有哪些关键的版本？

ES3.0： 1999

ES5.0:  2009

ES6.0:  2015, 从该版本开始，不再使用数字作为编号，而使用年份

ES7.0:  2016

## 块级邦定

### 声明变量的问题

使用var声明变量

1. 允许重复的变量声明：导致数据被覆盖
2. 变量提升：怪异的数据访问、闭包问题
3. 全局变量挂载到全局对象：全局对象成员污染问题

### 使用let声明变量

ES6不仅引入let关键字用于解决变量声明的问题，同时引入了块级作用域的概念

块级作用域：代码执行时遇到花括号，会创建一个块级作用域，花括号结束，销毁块级作用域

解决var声明变量的问题

1. let声明的变量不会挂载到全局对象
2. let声明的变量，不允许当前作用域范围内重复声明
3. 在块级作用域中用let定义的变量，在作用域外不能访问
4. 使用let不会有变量提升，因此，不能在定义let变量之前使用它

**底层实现上，let声明的变量实际上也会有提升，但是，提升后会将其放入到“暂时性死区”，如果访问的变量位于暂时性死区，则会报错：`“Cannot access 'a' before initialization”`。当代码运行到该变量的声明语句时，会将其从暂时性死区中移除。**

在循环中，用let声明的循环变量，会特殊处理，每次进入循环体，都会开启一个新的作用域，并且将循环变量绑定到该作用域（每次循环，使用的是一个全新的循环变量）

在循环中使用let声明的循环变量，在循环结束后会销毁

### 使用const声明常量

const和let完全相同，仅在于用const声明的变量，必须在声明时赋值，而且不可以重新赋值。

实际上，在开发中，应该尽量使用const来声明变量，以保证变量的值不会随意篡改，原因如下：

1. 根据经验，开发中的很多变量，都是不会更改，也不应该更改的。
2. 后续的很多框架或者是第三方JS库，都要求数据不可变，使用常量可以一定程度上保证这一点。

### const和let的区别

- const声明时必须赋值，切不可以重复赋值
- 在for循环中，循环变量不可以使用常量(i++ 变量)对象循环中可以使用

## 函数

### 参数默认值

只要给函数加上参数默认值，该函数会自动变成严格模式下的规则：arguments和形参脱离 没有映射关系了
尽量不要使用arguments了

形参和ES6中的let或const声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区。

```js
function test(a, b = 1) {
    console.log("arugments", arguments[0], arguments[1]); // arugments 1 2
    console.log("a:", a, "b:", b); // a: 1 b: 2
    a = 3;
    console.log("arugments", arguments[0], arguments[1]); // arugments 1 2
    console.log("a:", a, "b:", b); // a: 3 b: 2
} 
```

### 剩余参数

arguments的缺陷：

1. 如果和形参配合使用，容易导致混乱;  在非严格模式下，arguments与形参存在映射
2. 从语义上，使用arguments获取参数，由于形参缺失，无法从函数定义上理解函数的真实意图

ES6的剩余参数专门用于收集末尾的所有参数，将其放置到一个形参数组中。

语法:

```js
function (...形参名){

}
```

**细节：**

1. 一个函数，仅能出现一个剩余参数
2. 一个函数，如果有剩余参数，剩余参数必须是最后一个参数

### 箭头函数

箭头函数是一个函数表达式，理论上，任何使用函数表达式的场景都可以使用箭头函数

完整语法：

```js
(参数1, 参数2, ...) => {
    //函数体
}
```

this指向

1. 通过对象调用函数，this指向对象
2. 直接调用函数，this指向全局对象，严格模式this为undefined
3. 如果通过new调用函数，this指向新创建的对象
4. 如果通过apply、call、bind调用函数，this指向指定的数据
5. 如果是DOM事件函数，this指向事件源

**注意细节：**

- 箭头函数中，不存在this、arguments、new.target，如果使用了，则使用的是函数外层的对应的this、arguments、new.target
- 箭头函数没有原型
- 箭头函数不能作用构造函数使用

## 类

### 传统的构造函数的问题

1. 属性和原型方法定义分离，降低了可读性
2. 原型成员可以被枚举
3. 默认情况下，构造函数仍然可以被当作普通函数使用

### 类的特点

1. 类声明不会被提升，与 let 和 const 一样，存在暂时性死区
2. 类中的所有代码均在严格模式下执行
3. 类的所有方法都是不可枚举的
4. 类的所有方法都无法被当作构造函数使用
5. 类的构造器必须使用 new 来调用

## Symbol

符号设计的初衷，是为了给对象设置私有属性

特点：

- 没有字面量
- 使用 typeof 得到的类型是 symbol
- **每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同**
- 符号可以作为对象的属性名存在，这种属性称之为符号属性
  - 开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问
  - 符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性
  - Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性
  - ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号
- 符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换